Домашнее задание к занятию "3.2. Работа в терминале. Лекция 2"  

1. Какого типа команда cd?  (screen - 1.png)  

vagrant@vagrant:~$ type cd  
cd is a shell builtin  
cd - встроенная команда в оболочку shell  

Попробуйте объяснить, почему она именно такого типа: опишите ход своих мыслей, если считаете, что она могла бы быть другого типа.  

Я думаю, это связано с тем, чтобы быстрее выполнять часто используемые команды (cd одна из них), поскольку загрузка данных из оперативной памяти происходит быстрее по сравнению с дисками.  

2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l?  

grep -c <some_string> <some_file>  

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04? (у меня установлена Ubuntu 22.04)(screen - 3-1.png и 3-2.png)  

systemd(1)  

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала? (screen - 4.png)  

ls -l \test4 2>/dev/pts/2  

Сначало не мог монять, почему не работает. Потом разобрался, чтобы что-то перенаправить в другой терминал, сначало надо чтобы сессия этого терминала существовала. Создал пару сессий, команда заработала. Все есть на скриншоте. Возможно, достаточно было бы сделать эту команду из по root  

5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.(screen - 5.png)  

cat <new_file.txt >new_file2.txt  

6. Получится ли, находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?  
Если я правильно понял задание, то скорее всего пример решения может быть таким: (screen - 6.png)  

echo Привет > /dev/pts/1  

7. Выполните команду bash 5>&1. К чему она приведет?  (screen - 7.png)  

bash 5>&1 - запустит экземпляр bash с fd 5 и перенаправит его на fd 1 (stdout).  

Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?  

echo netology > /proc/$$/fd/5 выведет в терминал слово "netology". Это произойдёт потому что echo отправляет netology в fd 5  

Но если выполнить, например, echo netology > /proc/$$/fd/10, то получим ошибку No such file or directory.  
Или, если выполнить echo netology > /proc/$$/fd/5 в другой сессии, то тоже получим аналогичную ошибку.  

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? (screen - 8.png)  

ls /home/vagrant/test3 3>&2 2>&1 1>&3 | wc -l  

Пример вывода на скриншоте.  

9. Что выведет команда cat /proc/$$/environ? (screen - 9-1.png)  

Переменные окружения и их значения  

Как еще можно получить аналогичный по содержанию вывод?  

Эту информацию можно получить с помощью команд env и printenv (screen - 10-1.png, 10-2.png)  

10. Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.  

/proc/[pid]/cmdline - файл только для чтения, который содержит полную информацию о процессе из командной строки  
/proc/[pid]/exe - символическая ссылка на исполняемый файл процесса <PID>  

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo. (screen - 11.png)  

vagrant@vagrant:~$ grep sse /proc/cpuinfo  
sse4_2  

12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty.  
Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.  

Могу только предположить. При запуске команды с помощью ssh для удалённого сеансе не выделяется tty. Если же подключиться по ssh без указания команды, то tty будет выделен.  

Изучив man ssh, нашел параметр -t: включает отображение псевдотерминала на удаленной машине. (screen - 12.png)

ssh -t localhost 'tty'  

vagrant@vagrant:~$ ssh -t localhost 'tty'  
vagrant@localhost's password:  
/dev/pts/1  
Connection to localhost closed.  
vagrant@vagrant:~$ ssh -t localhost 'who'  
vagrant@localhost's password:  
vagrant  pts/0        2022-11-13 16:04 (10.0.2.2)  
vagrant  pts/1        2022-11-13 16:55 (127.0.0.1)  
Connection to localhost closed.  

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.  

reptyr установил: sudo apt-get install reptyr (screen - 13-1.png)   
Далее выполнил каждый шаг по инструкции:  
- Start a long running process, e.g. top  
- Background the process with CTRL-Z  
- Resume the process in the background: bg  
- Display your running background jobs with jobs -l, this should look like this:  
	[1]+ 1323 Stopped (signal) top  
	The -l in jobs -l makes sure you'll get the PID)  
- Disown the jobs from the current parent with disown top. After that, jobs will not show the job any more, but ps -a will.  (screen - 13-2.png)
- Start your terminal multiplexer of choice, e.g. tmux  
- Выполнил  sudo reptyr -T 1323  
- Закрыл сессию ssh  
- Подключился заново, далее выполнил две команды: screen, затем reptyr 1323. Увидел работающий процесс top  

Получилось это все далеко не с первого раза.  

14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте? что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.  

В первом случае имеем отказано в достeпе. (screen - 14.png)   

команда tee в linux принимает данные из одного источника и может сохранять их на выходе в нескольких местах.  

Во втором случае мы через sudo повышаем права tee. Соответственно у нас получилось создать файл в /root и вывести string на экран  










